\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle, language=Python}

\begin{document}

\section*{Parte 1: Testes de Unidade}

\subsection*{3.1 Testes de Entrada e Saída}
\begin{lstlisting}[caption={Testes de validação de entrada e saída para as operações básicas.}]
# tests/test_unidade.py

def test_entrada_saida_soma(self):
    resultado = self.calc.somar(5, 3)
    self.assertEqual(resultado, 8)
    self.assertEqual(self.calc.obter_ultimo_resultado(), 8)

def test_entrada_saida_subtracao(self):
    resultado = self.calc.subtrair(10, 4)
    self.assertEqual(resultado, 6)
    self.assertEqual(self.calc.obter_ultimo_resultado(), 6)

def test_entrada_saida_multiplicacao(self):
    resultado = self.calc.multiplicar(3, 7)
    self.assertEqual(resultado, 21)
    self.assertEqual(self.calc.obter_ultimo_resultado(), 21)
    
def test_entrada_saida_divisao(self):
    resultado = self.calc.dividir(20, 5)
    self.assertEqual(resultado, 4)
    self.assertEqual(self.calc.obter_ultimo_resultado(), 4)

# Teste extra para a categoria 3.1
def test_entrada_saida_potencia(self):
    resultado = self.calc.potencia(2, 3)
    self.assertEqual(resultado, 8)
    self.assertEqual(self.calc.obter_ultimo_resultado(), 8)
\end{lstlisting}

\subsection*{3.2 Testes de Tipagem}
\begin{lstlisting}[caption={Testes para garantir que operandos de tipos inválidos sejam rejeitados.}]
# tests/test_unidade.py

def test_tipagem_invalida_geral(self):
    operacoes = [self.calc.somar, self.calc.subtrair, self.calc.multiplicar, self.calc.dividir, self.calc.potencia]
    invalidos = [("5", 3), (10, None), ([], 2), ({}, 1)]
    
    for op in operacoes:
        for a, b in invalidos:
            with self.assertRaises(TypeError, msg=f"Falhou em {op.__name__} com ({a}, {b})"):
                op(a, b)

# Teste extra para a categoria 3.2
def test_tipagem_segundo_argumento_invalido(self):
    with self.assertRaises(TypeError):
        self.calc.somar(5, "3")
\end{lstlisting}

\subsection*{3.3 Testes de Consistência}
\begin{lstlisting}[caption={Testes para verificar a consistência do estado interno do objeto.}]
# tests/test_unidade.py

def test_consistencia_historico(self):
    self.calc.somar(2, 3)
    self.calc.multiplicar(4, 5)
    self.assertEqual(len(self.calc.historico), 2)
    self.assertIn("2 + 3 = 5", self.calc.historico)
    self.assertIn("4 * 5 = 20", self.calc.historico)

# Teste extra para a categoria 3.3
def test_consistencia_resultado(self):
    self.calc.somar(10, 5)
    self.assertEqual(self.calc.resultado, 15)
    self.calc.subtrair(self.calc.resultado, 5)
    self.assertEqual(self.calc.resultado, 10)
\end{lstlisting}

\subsection*{3.4 Testes de Inicialização}
\begin{lstlisting}[caption={Testes para garantir que a calculadora é inicializada corretamente.}]
# tests/test_unidade.py

def test_inicializacao(self):
    self.assertEqual(self.calc.resultado, 0)
    self.assertEqual(len(self.calc.historico), 0)

# Teste extra para a categoria 3.4
def test_inicializacao_tipo_objeto(self):
    self.assertIsInstance(self.calc, Calculadora)
\end{lstlisting}

\subsection*{3.5 Testes de Modificação de Dados}
\begin{lstlisting}[caption={Testes para o método que modifica o estado (limpar histórico).}]
# tests/test_unidade.py

def test_modificacao_historico(self):
    self.calc.somar(1, 1)
    self.assertEqual(len(self.calc.historico), 1)
    self.calc.limpar_historico()
    self.assertEqual(len(self.calc.historico), 0)

# Teste extra para a categoria 3.5
def test_modificacao_acumulativa_historico(self):
    self.calc.somar(1, 1)
    self.assertEqual(len(self.calc.historico), 1)
    self.calc.subtrair(2, 1)
    self.assertEqual(len(self.calc.historico), 2)
\end{lstlisting}

\subsection*{3.6 Testes de Limite Inferior}
\begin{lstlisting}[caption={Testes com valores mínimos, como zero e números negativos.}]
# tests/test_unidade.py

def test_limite_inferior(self):
    # Teste com zero
    resultado_zero = self.calc.somar(0, 5)
    self.assertEqual(resultado_zero, 5)
    # Teste com numeros negativos muito pequenos
    resultado_neg = self.calc.multiplicar(-1e-10, 2)
    self.assertEqual(resultado_neg, -2e-10)

# Teste extra para a categoria 3.6
def test_limite_inferior_negativos(self):
    resultado = self.calc.somar(-100, -200)
    self.assertEqual(resultado, -300)
\end{lstlisting}

\subsection*{3.7 Testes de Limite Superior}
\begin{lstlisting}[caption={Testes com valores máximos e próximos ao limite de float.}]
# tests/test_unidade.py

def test_limite_superior(self):
    resultado = self.calc.somar(1e10, 1e10)
    self.assertEqual(resultado, 2e10)
    
def test_limite_float_max(self):
    max_float = sys.float_info.max
    resultado = self.calc.multiplicar(max_float, 1)
    self.assertEqual(resultado, max_float)
    # Testar overflow
    with self.assertRaises(OverflowError):
         self.calc.potencia(max_float, 2)

# Teste extra para a categoria 3.7
def test_limite_superior_multiplicacao(self):
    resultado = self.calc.multiplicar(1e150, 1e150)
    self.assertEqual(resultado, 1e300)
\end{lstlisting}

\subsection*{3.8 Testes de Valores Fora do Intervalo}
\begin{lstlisting}[caption={Testes para entradas inválidas, como divisão por zero.}]
# tests/test_unidade.py

def test_divisao_por_zero(self):
    with self.assertRaises(ValueError):
        self.calc.dividir(10, 0)

# Teste extra para a categoria 3.8
def test_potencia_negativa_com_expoente_fracionario(self):
    # Isso resulta em um número complexo, levantando ValueError para floats
    with self.assertRaises(ValueError):
        self.calc.potencia(-4, 0.5)
\end{lstlisting}

\subsection*{3.9 Testes de Fluxos de Controle}
\begin{lstlisting}[caption={Testes que cobrem diferentes caminhos lógicos no código.}]
# tests/test_unidade.py

def test_fluxos_divisao(self):
    # Caminho normal
    resultado = self.calc.dividir(10, 2)
    self.assertEqual(resultado, 5)
    # Caminho de erro
    with self.assertRaises(ValueError):
        self.calc.dividir(10, 0)

# Teste extra para a categoria 3.9
def test_fluxos_soma(self):
    # Caminho normal
    resultado = self.calc.somar(1, 1)
    self.assertEqual(resultado, 2)
    # Caminho de erro (tipo inválido)
    with self.assertRaises(TypeError):
        self.calc.somar(1, "1")
\end{lstlisting}

\subsection*{3.10 Testes de Mensagens de Erro}
\begin{lstlisting}[caption={Testes que verificam se as mensagens de erro são claras.}]
# tests/test_unidade.py

def test_mensagens_erro_divisao(self):
    with self.assertRaises(ValueError) as cm:
        self.calc.dividir(5, 0)
    self.assertEqual(str(cm.exception), "Divisao por zero nao permitida")

# Teste extra para a categoria 3.10
def test_mensagens_erro_tipagem(self):
    with self.assertRaises(TypeError) as cm:
        self.calc.subtrair("a", 5)
    self.assertEqual(str(cm.exception), "Argumentos devem ser numeros")
\end{lstlisting}

\newpage
\section*{Parte 2: Testes de Integração}

\subsection*{4.1 Teste de Operações Sequenciais}
\begin{lstlisting}[caption={Testes de múltiplas operações em sequência.}]
# tests/test_integracao.py

def test_operacoes_sequenciais(self):
    # Sequencia: 2 + 3 = 5, depois 5 * 4 = 20, depois 20 / 2 = 10
    self.calc.somar(2, 3)
    resultado1 = self.calc.obter_ultimo_resultado()
    self.assertEqual(resultado1, 5)

    self.calc.multiplicar(resultado1, 4)
    resultado2 = self.calc.obter_ultimo_resultado()
    self.assertEqual(resultado2, 20)

    self.calc.dividir(resultado2, 2)
    resultado_final = self.calc.obter_ultimo_resultado()
    
    self.assertEqual(resultado_final, 10)
    self.assertEqual(len(self.calc.historico), 3)

# Teste extra para a categoria 4.1
def test_operacoes_sequenciais_com_subtracao_e_potencia(self):
    # Sequencia: 10 - 2 = 8, depois 8 ** 2 = 64
    self.calc.subtrair(10, 2)
    res1 = self.calc.obter_ultimo_resultado()
    self.assertEqual(res1, 8)
    
    self.calc.potencia(res1, 2)
    res2 = self.calc.obter_ultimo_resultado()
    self.assertEqual(res2, 64)
    self.assertIn("10 - 2 = 8", self.calc.historico)
    self.assertIn("8 ** 2 = 64", self.calc.historico)
\end{lstlisting}

\subsection*{4.2 Teste de Interface entre Métodos}
\begin{lstlisting}[caption={Testes de comunicação e interação entre diferentes métodos.}]
# tests/test_integracao.py

def test_integracao_historico_resultado(self):
    # 2^3 = 8
    self.calc.potencia(2, 3)
    # 8 + 2 = 10
    self.calc.somar(self.calc.obter_ultimo_resultado(), 2) 

    self.assertEqual(self.calc.obter_ultimo_resultado(), 10)
    self.assertEqual(len(self.calc.historico), 2)
    self.assertIn("2 ** 3 = 8", self.calc.historico)
    self.assertIn("8 + 2 = 10", self.calc.historico)

# Teste extra para a categoria 4.2
def test_integracao_limpar_historico_no_meio_das_operacoes(self):
    self.calc.somar(10, 20)
    self.assertEqual(len(self.calc.historico), 1)
    self.assertEqual(self.calc.resultado, 30)
    
    self.calc.limpar_historico()
    self.assertEqual(len(self.calc.historico), 0)
    
    self.calc.multiplicar(5, 5)
    self.assertEqual(len(self.calc.historico), 1) # Histórico recomeçou
    self.assertEqual(self.calc.resultado, 25) # Resultado foi atualizado
    self.assertNotIn("10 + 20 = 30", self.calc.historico)
    self.assertIn("5 * 5 = 25", self.calc.historico)
\end{lstlisting}

\end{document}